//===================================
// Utility operations.
//===================================
// Creates a new ECore annotation
// with the specified name,
// adding an EString to String
// map entry with the stated name
// and value.
//===================================
operation createAnn(name, key, value) {
	var ann = new Target!EAnnotation;
	ann.details.add(createDetail(key, value));
	ann.source = name;
	return ann;
}

//===================================
// Creates a new ECore annotation
// detail with the specified key
// and value, to be appended to a
// previously created annotation.
//===================================
operation createDetail(key, value) {
	var kvp = new Target!EStringToStringMapEntry;
	kvp.key = key;
	kvp.value = value;
	return kvp;
}

//===================================
// Creates a new ECore enum literal
// with the specified name and value.
//===================================
operation createLiteral(name, value) {
	var litVal = new Target!EEnumLiteral;
	litVal.name = name;
	litVal.value = value;
	return litVal;
}
//===================================
// Creates an ECore attribute with
// the specified name and type.
//===================================
operation createAttr(name, type) {
	var attr = new Target!EAttribute;
	attr.name = name;
	attr.eType = type;	
	return attr;
}


//===================================
// The follwing pre blocks initialize
// the Circuit ECore model by
// creating a series of constructs,
// including key EuGENia annotations.
//===================================
// Creates the Circuit package.
//===================================
pre eCoreInit_createPackage {
	var pkg = new Target!EPackage;
	pkg.name = 'circuit';
	pkg.nsPrefix = 'circuit';
	pkg.nsURI = 'http://www.intec.edu.do/abdiel/circuit';
}

//===================================
// Creates the diagram base Circuit
// class.
//===================================
pre eCoreInit_createCircuitClass {
	var circuit = new Target!EClass;
	pkg.eClassifiers.add(circuit);
	circuit.eAnnotations.add(createAnn('gmf.diagram', 'onefile', 'true'));
	circuit.name = 'Circuit';
	// TODO Add 'rcp=true' detail
}
//===================================
// Creates the Polarity enumeration.
// TODO Could this be a rule instead?
//===================================
pre eCoreInit_createPolarityEnum {
	var polarity = new Target!EEnum;
	pkg.eClassifiers.add(polarity);
	polarity.name = 'Polarity';
	polarity.eLiterals.add(createLiteral('NEUTRAL', 1));
	polarity.eLiterals.add(createLiteral('POSITIVE', 2));
	polarity.eLiterals.add(createLiteral('NEGATIVE', 3));
}

//===================================
// Creates the instance Pin class.
//===================================
pre eCoreInit_createPin { 
	var pin = new Target!EClass;
	pkg.eClassifiers.add(pin);
	pin.name = 'Pin';
	pin.eAnnotations.add(createAnn('gmf.node', 'label', 'name'));
	var eString = ECore!EDataType.all.selectOne(dt|dt.name='EString');
	pin.eStructuralFeatures.add(createAttr('name', eString));
	pin.eStructuralFeatures.add(createAttr('polarity', polarity));
}

//===================================
// Creates the abstract Part class.
//===================================
pre eCoreInit_createPart {
	var part = new Target!EClass;
	pkg.eClassifiers.add(part);
	part.name = 'Part';
	part.abstract = true;
	part.eAnnotations.add(createAnn('gmf.node', 'label', 'name'));
	part.eStructuralFeatures.add(createAttr('name', eString));
	// Add pin container
	var pinCont = new Target!EReference;
	part.eStructuralFeatures.add(pinCont);
	pinCont.name = 'pins';
	pinCont.containment = true;
	pinCont.eType = pin;
	pinCont.upperBound = -1;
	// Add GMF compartment annotation to pin container
	var compartment = createAnn('gmf.compartment', 'collapsible', 'false');
	compartment.details.add(createDetail('layout', 'list'));
	pinCont.eAnnotations.add(compartment);
}

//===================================
// Creates the Wire link class.
//===================================
pre eCoreInit_createWire {
	var wire = new Target!EClass;
	pkg.eClassifiers.add(wire);
	wire.name = 'Wire';
	var gmfLink = createAnn('gmf.link', 'source', 'source');
	gmfLink.details.add(createDetail('target', 'target'));
	// TODO create OCL contraints - no self loops
	wire.eAnnotations.add(gmfLink);
	//
	var source = new Target!EReference;
	wire.eStructuralFeatures.add(source);
	source.name = 'source';
	source.containment = false;
	source.eType = pin;
	//
	var dest = new Target!EReference;
	wire.eStructuralFeatures.add(dest);
	dest.name = 'target';
	dest.containment = false;
	dest.eType = pin;
}

//===================================
// Creates the abstract Part class.
//===================================
post eCoreInit_addDiagramContents {
	// Add parts to circuit
	var cont = new Target!EReference;
	circuit.eStructuralFeatures.add(cont);
	cont.name = 'parts';
	cont.containment = true;
	cont.eType = part;
	cont.upperBound = -1;
	// Add wires to circuit
	cont = new Target!EReference;
	circuit.eStructuralFeatures.add(cont);
	cont.name = 'wires';
	cont.containment = true;
	cont.eType = wire;
	cont.upperBound = -1;	
}

//===================================
// PartSpec2EClass rule
// For each concrete PartSpecitication
// in the source ABDIEL model, create
// an ECore EClass in order to allow
// EuGENia to generate a tool and graph
// node for it.  The generated EClass
// extends Part and has attributes that
// mirror the transformed PartSpecification's
// associated Properties.
//===================================
rule PartSpec2EClass
transform partSpec : Source!PartSpecification
to eClass : Target!EClass {
	var ckt = Target!EPackage.all.selectOne(p|p.name='circuit');
	eClass.name := partSpec.name;
	ckt.eClassifiers.add(eClass);
	eClass.eSuperTypes.add(Target!EClass.all.selectOne(c|c.name='Part'));
	//
	var eString = ECore!EDataType.all.selectOne(dt|dt.name='EString');
	for(prop:Source!Property in partSpec.properties) {
		var attr = new Target!EAttribute;
		eClass.eStructuralFeatures.add(attr);
		attr.name = prop.name;		
		attr.eType = eString;
	}
}

//===================================
// Informative post block to let us know
// the transformation has finished.
//===================================
post wrapUp {
 	'Transformation finished'.println();
}